## 2026-02-10 - US-001
- Worked: Scaffolding Vite + TypeScript in a temp folder and syncing to repo root avoided non-empty directory setup failures.
- Pitfall: `bun create vite .` cancelled in a non-empty directory, so direct in-place scaffolding was unreliable.
- Decision: Keep Convex connected at the frontend provider/client layer first, then initialize cloud deployment with `bunx convex dev` when credentials are available.
- Reuse: For future stories, use Bun scripts (`typecheck`, `test`, `build`) as the stable validation baseline before feature-level checks.

## 2026-02-10 - US-002
- Worked: Using a Convex mutation for registration with PBKDF2 + per-user salt handled secure password storage and session creation in one server flow.
- Pitfall: React tests failed after introducing Convex hooks until `App` was rendered under `ConvexProvider`.
- Decision: Keep client calls typed with `makeFunctionReference` for now to avoid blocking on generated API files.
- Reuse: For upcoming auth stories, persist only session tokens in local storage and resolve current user through a token-backed Convex query.

## 2026-02-10 - US-003
- Worked: Adding shared Convex session helpers made register/login/logout flows consistent while keeping token storage client-only.
- Pitfall: Session state can momentarily hydrate as unknown, so redirect logic must wait for `getSessionUser` to resolve before forcing logout.
- Decision: Use one generic login failure message for missing users and bad passwords to avoid credential enumeration.
- Reuse: Treat authenticated UI as a protected view backed by a token query; on token mismatch, clear local storage and send users back to login.

## 2026-02-10 - US-004
- Worked: Introducing an `authAccounts` table with provider + subject keys created a reusable identity boundary while keeping current credentials auth intact.
- Pitfall: Migrating toward provider-linked auth can break existing credential lookups unless login keeps a fallback path for legacy records.
- Decision: Keep social buttons visibly disabled with clear "coming soon" copy so UI promises future OAuth without implying current support.
- Reuse: For future OAuth providers, map provider identity into `authAccounts` first, then issue sessions through the same shared auth/session path.

## 2026-02-10 - US-005
- Worked: A token-gated Convex `createServer` mutation plus `listMyServers` query gave immediate realtime list updates after creation with minimal client state.
- Pitfall: Hook order matters in React; dependent queries must be declared after derived auth state to avoid referencing values before initialization.
- Decision: Scope "my servers" to owner-created servers for this story and defer membership-based listing to the join/leave story.
- Reuse: For future protected features, centralize session-token validation in shared Convex helpers so every query/mutation enforces auth consistently.

## 2026-02-10 - US-006
- Worked: A dedicated `serverMemberships` table plus a combined owner/member server query made join/leave updates appear immediately in one realtime list.
- Pitfall: Free-text server IDs can fail Convex ID validation before business logic, so UI must surface safe join errors clearly.
- Decision: Keep owner membership implicit (via `servers.ownerId`) and block owner leave operations to preserve ownership invariants.
- Reuse: For upcoming channel/message permissions, enforce access with shared auth helpers and membership index lookups in Convex before any mutation logic.

## 2026-02-10 - US-007
- Worked: Adding a dedicated owner-only `deleteServer` mutation and wiring it to the owner row action kept server removal simple and realtime.
- Pitfall: Related data cleanup can be missed; deleting `serverMemberships` before deleting the server avoids orphaned membership records.
- Decision: Define this story's delete behavior as hard-delete for server + memberships (channels/messages are deferred until those tables exist).
- Reuse: For future cascading deletes, implement cleanup in Convex mutations where authorization and relational teardown can be enforced together.

## 2026-02-10 - US-008
- Worked: Modeling channels with a server-scoped uniqueness index and membership-gated Convex queries provided realtime updates without extra client cache logic.
- Pitfall: Channel permissions need explicit rule boundaries; allowing delete only for server owners or channel creators keeps moderation behavior predictable for MVP.
- Decision: Keep channel creation open to any server member while enforcing list/create/delete authorization in Convex.
- Reuse: Drive channel UI from selected server state and let Convex realtime queries handle create/delete refresh automatically.

## 2026-02-10 - US-009
- Worked: Adding a channel-scoped messages table with a `by_channel_id_created_at` index made chronological realtime message rendering straightforward.
- Pitfall: Introducing messages requires delete-path cleanup; channel/server deletion now needs message cascading to avoid orphaned rows.
- Decision: Enforce channel access by re-checking server ownership/membership for both `sendMessage` and `listMessages` to keep read/write authorization symmetric.
- Reuse: For future chat features (edits/deletes), return enriched message view models (author + timestamp) directly from Convex queries to keep UI logic thin.

## 2026-02-10 - US-010
- Worked: A dedicated `deleteMessage` Convex mutation plus per-message `canDelete` metadata enabled immediate UI updates through existing realtime queries.
- Pitfall: Delete permissions need explicit moderator behavior; without an admin role in MVP, ownership override must be codified server-side.
- Decision: Define moderation override as server owner can delete any message, while message authors can always delete their own.
- Reuse: For future moderation features, compute UI capabilities (`canDelete`) in Convex view models so the client stays permission-thin and consistent.

## 2026-02-10 - US-011
- Worked: Parsing URL paths into an app route model let `/login`, `/register`, and `/app/servers/:serverId/channels/:channelId` stay in sync with Convex-backed selection state.
- Pitfall: Route params can become stale when server/channel membership changes, so effects must normalize invalid params back to safe defaults.
- Decision: Keep routing dependency-free by using browser history APIs, with auth guards and selection normalization handled in React effects.
- Reuse: For future deep-linkable features, drive selected entities from URL params and navigate after create/join actions to preserve shareable state.

## 2026-02-10 - US-012
- Worked: Enforcing session-token format checks before DB lookups reduced malformed-auth paths while keeping protected Convex handlers consistent.
- Pitfall: Rate limiting in a serverless mutation context has no client IP, so keying on normalized login names is easy to bypass with rotating identifiers.
- Decision: Use a per-action (`login`/`register`), fixed-window limiter in Convex with temporary lockouts and generic error copy to avoid account enumeration.
- Reuse: Keep auth hardening centralized in `convex/auth.ts` and reuse helper-level guards in feature modules (`servers/channels/messages`) for baseline input and access validation.

## 2026-02-10 - US-017
- Worked: Adding dedicated `friendRequests` and `friendships` tables with pair-key lookups made duplicate prevention and accepted-friend queries deterministic.
- Pitfall: Duplicate request checks must be bidirectional; only validating requester->recipient misses pending requests in the opposite direction.
- Decision: Keep request response rights recipient-only and create friendships only on explicit accept to preserve a clear mutual request flow.
- Reuse: For future DM routing, consume the `listFriends` query result directly so friend relationships remain server-authoritative and realtime.

## 2026-02-10 - US-013
- Worked: Swapping the lint script to `oxlint .` and pruning ESLint packages kept linting setup minimal while preserving Bun-based workflows.
- Pitfall: Lockfile contents can hide stale ESLint transitive entries until `bun install` is rerun after dependency cleanup.
- Decision: Remove `eslint.config.js` entirely and rely on Oxlint defaults for the current TypeScript/React surface.
- Reuse: For future toolchain migrations, change scripts first, remove old config/deps in one pass, then validate with full project checks.

## 2026-02-10 - US-014
- Worked: A single GitHub Actions workflow with explicit Bun install/typecheck/lint/test/build steps mirrored local validation and kept CI behavior predictable.
- Pitfall: Running story work in a bare-repo setup required creating a dedicated worktree branch first; branch switching in existing worktrees would violate story isolation.
- Decision: Trigger CI on both `pull_request` and `push` (main + owner branches) so checks run before merge and on branch updates.
- Reuse: For upcoming stories, keep CI steps aligned with `package.json` scripts so local debugging and pipeline failures stay one-to-one.
 
## 2026-02-10 - US-015
- Worked: Restructuring the authenticated app into a dedicated server icon rail, channel sidebar, and message pane kept existing data/mutation logic intact while delivering the new shell UX.
- Pitfall: Global dark themes can make validation and status text hard to scan unless accent and error colors are tuned for contrast against deep slate backgrounds.
- Decision: Keep all management interactions in the channel pane for now so the icon rail stays focused on server switching and remains usable on narrow mobile widths.
- Reuse: For future UI stories, prefer class-level visual overhauls around stable handlers instead of rewiring app state to reduce regression risk.

## 2026-02-10 - US-018
- Worked: Treating each accepted friendship as the DM channel key kept Friends navigation simple while preserving realtime updates.
- Pitfall: Merging server and DM channel flows in one view requires explicit branching for selection, query args, and permission UI.
- Decision: Use a virtual `Friends` server entry and route DM send/list through dedicated Convex direct message handlers.
- Reuse: Keep special spaces like DMs as virtual navigation entries layered over existing server routing primitives.

## 2026-02-10 - US-026
- Worked: Splitting the app into route/auth/shell/panel modules reduced cross-cutting edits and kept each feature surface easier to reason about.
- Pitfall: Moving logic across files can leave stale imports and type references that only show up once full TypeScript validation runs.
- Decision: Keep auth/session flow in `App.tsx` and move server/channel/message data and actions into dedicated panel components.
- Reuse: For future UI stories, add focused components first, then migrate handlers and queries closest to each component to avoid regressions.

## 2026-02-10 - US-019
- Worked: Introducing a dedicated `/app/settings` route and centralizing create/join/leave/delete actions in one settings surface removed management noise from chat interactions.
- Pitfall: Splitting authenticated routes into chat/settings sections required careful type narrowing to avoid passing settings routes into chat-only panels.
- Decision: Keep chat panes focused on navigation and messaging only, while preserving all server/channel management capabilities inside `SettingsPage`.
- Reuse: For future shell-level UX changes, model route sections explicitly (`chat` vs `settings`) so feature-specific panels stay type-safe and isolated.

## 2026-02-10 - US-021
- Worked: Converting server actions into a true overlay dialog made outside-click dismissal straightforward and predictable.
- Pitfall: UI tests can leave multiple rendered instances in the DOM, so role/title queries should handle duplicates when asserting modal behavior.
- Decision: Close on overlay click and Escape, while stopping propagation inside the dialog and restoring focus to the trigger.
- Reuse: For future modal work, keep dismissal logic in one component-level state flow and add focused interaction tests for overlay vs content clicks.
## 2026-02-10 - US-023
- Worked: Using Tailwind `group-hover` and `group-focus-within` on each message row hid delete actions by default without changing message permissions.
- Pitfall: Pure hover behavior breaks keyboard discoverability, so focus states must also reveal row actions.
- Decision: Keep delete controls fully visible while deletion is pending so users keep clear feedback during mutation latency.
- Reuse: For future action-density cleanup, prefer opacity-based reveal patterns that preserve existing handlers and authorization logic.

## 2026-02-10 - US-016
- Worked: Route normalization effects in server and channel panels reliably redirected server-only paths to the first available channel once data loaded.
- Pitfall: Invalid URL params can look valid until queries resolve, so fallback navigation needs to wait for server/channel data before replacing history.
- Decision: Keep server validity checks in the servers sidebar and channel validity checks in the channels panel to avoid mixed responsibilities.
- Reuse: For future deep-link routes, pair every URL-driven selection with a "first valid fallback" effect to recover cleanly from stale links.

## 2026-02-10 - US-024
- Worked: Removing timestamp rendering in `MessagesPanel` kept the chat rows cleaner without touching message queries, ordering, or realtime subscriptions.
- Pitfall: Message header layout depends on compact typography; removing metadata can leave awkward spacing if the author/delete row isn't preserved.
- Decision: Keep the existing author label and delete control structure unchanged, only dropping the timestamp line from the UI.
- Reuse: For low-risk chat UI cleanup stories, prefer targeted render-only edits over data-shape changes to avoid backend or realtime regressions.

## 2026-02-10 - US-025
- Worked: Moving the send control inline with the textarea and switching it to an icon-only button made the compose area feel faster without changing mutation wiring.
- Pitfall: Keyboard submit can regress when switching to a compact composer; relying on textarea default Enter behavior won't submit forms consistently.
- Decision: Submit on Enter and keep Shift+Enter for newline so both quick-send and multiline authoring remain available.
- Reuse: For future message composer tweaks, keep form submission centralized and layer UI/keyboard ergonomics on top to avoid backend-impacting changes.

## 2026-02-11 - US-028
- Worked: Routing both keyboard and button sends through the same form submit path kept validation and auth behavior aligned while adding richer key handling.
- Pitfall: Enter key shortcuts can conflict with IME composition; without an `isComposing` guard, message send can trigger unexpectedly mid-composition.
- Decision: Use plain Enter to submit, reserve Ctrl+Enter for newline insertion, and block whitespace-only sends client-side before mutation calls.
- Reuse: For future composer UX stories, keep backend trim/length validation as the source of truth and add client-side guards only to prevent avoidable round trips.
